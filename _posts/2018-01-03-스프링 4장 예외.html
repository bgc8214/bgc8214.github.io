---
layout: post
title:  "스프링 스터디 4장 예외"
date:   2019-01-03 16:00:00 -0400
subtitle: "자바개발자의 예외 처리"
categories : 스프링
background: '/img/posts/02.jpg'
---

<h2>초난감 예외처리</h2>
<p>예외를 try / catch 를 통해서 잡는 거는 좋은 일이다. 하지만 catch 안에서 아무것도 하지 않는 것은 안하니만 못한 일이다. 그 예외로 비정상적인 동작이 일어났을 것이기 때문이다</p>

<p>그리고 안에서 e.printstackTrace()를 통한 로그를 찍는 것만 하는 것도 해서는 안될 것이다. 운영서버에 올라가면 순식간에 묻혀버리는데, 개발자가 확인이 너무 어렵다</p>

<p><b>핵심 원칙은 모든 예외는 적절하게 복구 되던지, 작업을 중단시키고 운영자 or 개발자에게 통보 해야한다는 것 이다 </b>
예외를 조취할 방법이 없다면 그냥 던지는 방식으로 책임을 전가해라 </p>
<p>그리고 무책임하게 Exception을 계속 throws하는 것도 용납되지 않는다. 이 메소드 선언에서는 더이상 의미있는 정보는 알수 없게 된다</p>

<h2>예외의 종류와 특징</h2>
<p>자바의 예외는 세 종류로 분류 할 수 있다. 1. Error : 시스템에 비정상적 상황이 발생한 경우 쓰이는 예외이다. <b>VM에서 발생하는 것이기 때문에 어플리케이션에서는 잡으려고 하지 말자</b> OutOfMemoryError나 ThreadDeath 같은 에러인데, 어차피 대응 할 수 없다 2. Exception과 체크 예외 : 개발자들이 만든 어플리케이션 코드의 작업 중 예외가 발생한 경우이다. 체크 예외가 발생할 수 있는 메소드를 쓰면 반드시 예외를 처리하는 코드도 있어야 한다. catch로 잡든 throws로 던지는 방식을 쓰지 않으면 컴파일 에러가 발생한다. IOException이나 SQLExeption 등이 있다. 3. RuntimeException과 언체크/런타임 예외 : 프로그램의 오류가 있을 때 발생한다. catch문으로 잡거나 throws로 선언하지 않아도 된다. NullPointerException이나, IllegalArgumentException 등 이 있다. 피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 사용된다 </p>

<h2>예외처리 방법</h2>
<p>예외 복구 : 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다. 체크 예외는 이렇게 예외를 어떻게든 복구할 가능성이 있는 경우에 쓰는 것이다 (재시도를 한다던지..)</p>
<p>예외처리 회피 : 호출한 쪽으로 던지는 방식이다. 바로 throws로 던지던지, catch에서 로그를 남기고 다시 던지든 할 수 있다. 회피는 의도가 분명해야 한다. 긴밀한 관계에 있는 다른 오브젝트가 책임을 지거나, 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 확신이 있어야 한다.</p>
<p>예외 전환 : 예외처리 회피와 비슷하지만, 적절한 예외로 전환해서 던진다는 특징이 있다. 사용하는 목적은 1. 내부에서 발생한 예외가 적절한 의미를 부여하지 못할 경우 알려주기 위해서. SQLException인데, 아이디 중복일 경우를 쉽게 알려줄 수 있다. 이 경우 원래 발생한 에외를 포함하는 중첩 예외를 쓰는 게 좋다(getCause()로 확인이 가능하고, 에러의 생성자나 initCause()메소드로 근본이 되는 예외를 넣자 2. 예외를 처리하기 쉽고 단순하게 만들기 위해서 쓴다. 주로 에러처리를 강제하는 체크예외를 런타임 예외로 바꾸는 경우 쓴다. 어차피 복구불가능한 예외라면 빨리 런타임 예외로 던져서 불필요한 throws를 없애자. 예외처리 서비스 등을 이용해 로그를 남기고, 사용자에게는 안내 메시지를 남기는 식으로 쓰자! </p>
<p>NOS ApplicationException은 RuntimeException으로 만들어져있다. 이 경우 처리하지 말고 밖으로 던지는 것이 목적이 되는 것이라 생각하면 된다. RTCode로 메시지를 남기는 형식이 될 것 이다.</p>
<h2>예외처리 전략</h2>
<p>런타임 예외의 보편화 : 예전에는 예외가 나와도 작업이 중단되지 않고 복구했다. 하지만 엔터프라이즈 환경은 수많은 사람이 쓰고 독립적인 작업환경이 된다. 예외가 발생한 해당 작업만 중단시키면 된다. 애초에 작업을 일시 중지하고 복구할 수 있는 방법도 없다. 차라리 예외를 파악하고 차단해버리는 것이 좋은 방법이 된다. </p>

<h2>애플리케이션 예외</h2>
<p>시스템이나 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적 발생하고 반드시 catch해서 조취를 취하도록 요구하는 것이 애플리케이션 예외이다. 이런 메소드 설계는 두 가지 방법이 있다. 1. 다른 종류의 리턴값을 준다. 하지만 리턴 값에 대한 명확한 정의 및 코드화를 안하면 관리가 어렵다. 2. 예외 상황에서 비즈니스적인 의미를 가진 예외를 던진다.  </p>

<h2>JdbcTemplate SQLException은 어떻게 된거야</h2>
<p>SQLException은 개발자가 코드에서 복구할 수 있는 예외가 아니다. 빨리 예외를 던져서 개발자가 인지할 수 있도록 하는 것이 좋다. Spring은 이러한 전략을 쓴다. SQLException을 런타임 예외로 전환해서 밖으로 던져버리게 한다</p>

<h2>예외 전환</h2>
<p>SQLException을 런타임 예외로 변경하는 것은 다루기 어려운 상세한 예외정보를 의미있고 일관성 있는 예외로 전환해서 추상화해주려는 용도로도 쓴다.</p>
<h3>JDBC의 한계</h3>
<p>JDBC는 DB사용을 추상화된 API로 정의해서 각 업체가 드라이버를 제공하게 해준다. 하지만 DB종류에 상관없이 유연하게 쓸 수 있는 것은 아니다</p>
<p>비표준 SQL : 각 DB마다 자신에게 맞는 최적화 SQL 문법이 있다. 이걸 다 맞추려면 DAO를 DB별로 만들거나 SQL을 외부에서 독립시켜서 쓰게 해야 하는 것이다</p>
<p>호환성 없는 SQLException의 DB 에러 정보 : DB마다 에러의 종류와 원인도 제각각이다. 그래서 JDBC는 SQLException 하나로 묶어서 던져버린다. 그리고 SQLException에서 SQL상태 정보를 가져오는 것도 DB마다 다르다.</p>
<p>스프링은 이미 DB별 에러코드를 분류하고 매핑정보 테이블을 가지고 있다. SQLException을 단지 런타임 예외로 전환하는 것이 아니라 하위의 해당 에러에 맞는 클래스로 매핑준다. 따라서 유저는 에러 코드 상관 없이 매핑된 에러를 사용하면 DB가 변경되더라도 동일한 에러를 받을 수 있게 된다</p>

<h2>DAO 인터페이스와 DataAccessException 계층구조</h2>
<p>DataAccessException는 JDBC에만 쓰는 게 아니라 자바 데이터 엑세스 기술에 발생하는 예외에 다 적용된다. JPA, iBatis 등 의미가 같은 예외라면 엑세스 기술의 종류와 상관없이 일관된 에외를 발생하게 한다 </p>
<p>DAO를 쓰면 내부에서 어떤 데이터 액세스 기술을 쓰는지 알 필요가 없다. 그런데 각자가 다른 예외를 던지면 메소드 선언이 달라지니, 같이 사용할 수 없게 된다. Hibernate, JPA 등 은 런타임 예외를 던지기 때문에 throws 선언을 할 필요가 없는데, JDBC는 SQLException이기 때문에 런타임 예외로 포장해서 사용하면 된다. 그래도 완벽한 것은 아니다. 의미있게 처리해야 되는 중복키 에러 같은 것도 결국은 다른 종류의 에러가 던져지기 때문이다.</p>
<p>하지만 스프링은 DataAccessException의 계층구조에 다 정리해두었다. 각각에서 발생하는 다른 똑같은 의미지만 다른 이름의 Exception을 추상화해서 사용하게 한다. 일부 DB에서 발생하는 Exception도 묶어서 공통적으로 사용하도록 만들었다.</p>
<p>그렇다고 해서 완벽한 것은 아니다. DuplicateKeyException은 아직 JDBC에서만 발생하고, Hibernate는 더 상위에 있는 DataIntegrityViolationException으로 변경되는 한계가 있다. </p>

