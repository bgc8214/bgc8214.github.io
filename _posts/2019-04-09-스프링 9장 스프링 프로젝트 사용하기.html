---
layout: post
title:  "스프링 스터디 9장 스프링 프로젝트 시작하기"
date:   2019-04-09 20:00:00 -0400
subtitle: "오브젝트 중심 아키텍처"
categories : 스프링
background: '/img/posts/03.jpg'
---

<h2>오브젝트 중심 아키텍처</h2>
<p>도메인 모델을 반영하는 오브젝트 구조를 만들어 두고, 그것을 각 계층에서 정보를 전송하는 데 사용하는 구조이다. 관계형 DB의 엔티티 구조와 유사한 형태일 가능성이 높다</p>
<p>카테고리와 상품이라는 모델에서 데이터를 가져온다고 하면, 데이터 중심 아키텍처에서는 SQL에서 조인하여 해당 값을 Map, 배열에 담게 된다. 이걸 서비스 계층에서 받게 되면, DAO 에서 어떤 필드 이름을
사용해서 값을 가져오는지, 몇 개의 필드를 사용하는 지를 다 알아야한다. 특히 필드이름이나 개수가 변경되면 서비스 계층의 코드도 같이 변경되야 하는 문제가 있다.</P>
<p>오브젝트 중심의 아키텍처는 두 개의 도메인을 만들어서 사용하게 된다. SQL의 결과를 두 개의 도메인에 나눠서 넣고, 이 모델은 서비스 계층, DAO 등 어떤 곳에서도 동일하게 사용하게 된다.
도메인에서 서로 간의 레퍼런스를 가지게 하여, Set 등을 통해 어떤 관계를 가지고 있는 지도 확인이 가능하다. </p>
<p>한 예로 상품의 가격의 합을 계산하려면, 오브젝트 중심 아키텍처에서는 카테고리 내, Set을 순회하며 가격을 합치면 되지만, 데이터 중심 방식에서는 sum을 구하는 SQL을 새로 작성하거나, 가격만 리스트로 넘겨주는 코딩이
추가로 들어가야 한다. 더 나아가 여러 카테고리에서의 합을 구하려면 훨씬 어려운 SQL이나 코딩이 추가될 것이다.</p>
<p>단점도 존재하는데, 최적화된 SQL을 사용하는 것 보다는 성능면에서 못할 수 있다. DAO에서는 어떤 비즈니스 로직을 탈지 모르기 때문에 필드의 모든 값을 채우는 경우가 대부분
이기 때문이다. 원하는 필드만 가져오도록 할 수도 있는데, 이런 경우 안쓰는 필드에 NULL이 들어가는 문제가 있다. 사실 이 문제는 지연된 로딩 (Lazy loading)을 쓰면 해결된다.
이를 사용하면 관계하는 오브젝트가 필요한 경우에 DB에서 다이나믹하게 읽어올 수 있게 된다. 코드에서는 전체 필드를 다 가져온다고 사용하면 된다. 가장 편리한것은 ORM(Object RDB Mapping)기술을 사용하는 것이다.
일반적으로 하이버네이트나 JPA를 많이 쓰는데, 알아서 lazy loading을 해주기 때문에 편리하다</p>
<h2>빈약한 데이터 오브젝트 방식</h2>
<p>도메인 오브젝트에 정보만 담겨있고 정보를 활용하는 아무런 기능도 없는 방식이다. 스프링 개발자가 흔히 사용하는 방식이다. 비즈니스 로직은 모두 서비스 계층에서 처리한다</p>

<h2>풍성한 데이터 오브젝트 방식</h2>
<p>좀 더 객체지향적인 특징을 살린 방식으로, 도메인 오브젝트가 가진 정보에 깊은 연관이 있는 로직의 경우 해당 도메인 오브젝트에서 처리하도록 하는 것이 풍성한 방식이다.
이전에 본 자신의 합계를 계산하는 방식을 도메인 오브젝트 내에서 함수로 가지고 있는 것이 예가 될 수 있다. 이렇게 하는 것이 더 응집도가 높다. 서비스 계층에서 하게 되면,
해당 기능을 사용하려면, 그 서비스를 DI받고 사용하는 과정이 들어가고, 실제로 개발자가 그 기능이 어떤 서비스에 있는지 몰라서 직접 개발을 하는 문제가 생길 수 있다. 하지만
도메인 오브젝트에서 해당 기능을 갖고 있다면, 어떤 계층에서든지 동일하게 사용할 수 있는 장점이 있다. 이렇게 한다고 해서 서비스 계층이 필요없어 지는 것이 아니다.
도메인 오브젝트는 다른 서비스 계층이나 DB에 접근 할 수 없기 때문에 서비스 계층은 관련 기능을 로직으로 제공해야 한다. 도메인 오브젝트는 스프링 빈이 아니기 때문에
다른 서비스를 DI 받을 수 없다.</p>
<img data-action="zoom" src='{{ "/img/posts/spring/spring09_1.png" | relative_url }}' alt='absolute'>

<h2>도메인 계층 방식</h2>
<p>도메인 오브젝트에서도 DAO나 다른 서비스를 쓰고 싶어서 나온게 도메인 계층 방식이다. 도메인이 하나의 계층으로 영향력이 더 커지게 된다.
첫 번째 특징은 도메인 오브젝트에 종속적인 로직은 여기서 다 처리한다는 점이다. 둘 째는 다른 계층의 기능을 사용할 수 있다는 점이다. 하지만 아까는 빈이 아니라 DI를 못받는 다고 했는데,
이를 이용하기 위해서 AOP를 쓰게 된다. AOP로 다른 빈을 주입받아서 사용하게 되는데, 이를 통해 더 많은 일을 하게 된다. 서비스 계층의 역할이 굉장히 줄지만 트랜잭션이나
여러 계층의 복합적인 로직을 위해서는 아직 필요하다.</p>
<p>도메인 오브젝트를 전 계층에서 쓰게 할지, 아니면 도메인 계층에서 쓰게 할지는 중요한 선택이다. 기존처럼 도메인 오브젝트를 전 영역에서 쓰게하는 것은 정말 간단하고 단순하다.
하지만 다른 영역에서 도메인에 있는 중요한 로직들도 수행할 수 있다는 단점이 있다. 이를 위해서 개발 가이드 라인이나, AspectJ를 사용한 정책을 강제화 하는 방식이 있다.(포인트 컷 표현으로
특정 계층의 오브젝트가 사용할 수 있는 메소드를 제한 가능) 그리고 도메인 오브젝트가 도메인 계층을 벗어나지 못하게 할 수 있다. 이를 위해서는 다른 계층에는 DTO (Domain Transfer Object)를
별도로 만들어서 제공하면된다. DTO는 기능이 없기 때문에 안전하게 사용가능하다.</p>
<p>도메인 계층은 사용되고 버려지고, 상태정보를 가지기 때문에 싱글톤도 안되고, 스프링 빈도 아니다. 이런 불편함에도 사용해야 하는 경우는
매우 복잡하고 변경이 잦은 도메인을 가졌을 경우이다. 복잡한 로직을 도메인 계층에 반영하고, 변화할 때 도메인 계층에서 빠르게 변경하기 위함이다. 응집도가 높기 때문에
테스트도 쉽다.</p>

<h2>스프링 애플리케이션을 위한 아키텍처 설계</h2>
<p>아키텍처는 기술이나 시스템 환경에 따라 여러 결정 및 변수가 있다. 계층형 아키텍쳐도 3계층 구조를 주로 쓰지만 꼭 세 개가 아니라 두개로 해도 큰 상관이 없다.
서비스 계층이 필요없을 만큼 비즈니스 로직이 단순하면 서비스 계층과 데이터 액세스 계층을 합칠 수 있다. 그러나 프레젠테이션과 서비스 계층을 합치는 것은 권장되지 않는다.
트랜잭션의 경계를 설정하기가 애매하기 때문이다. 프레젠테이션 계층은 주로 MVC로 알려진 패턴을 많이 쓴다. 또한 프레젠테이션 계층은 서버를 떠나 클라이언트까지 확장된다.
코드가 클라이언트로 다운로드 되서, 거기서 서비스 계층과 통신하는 구조이다. </p>
<p>엔터프라이즈 애플리케이션은 수많은 사용자가 접근하기에, 사용자에게 계속 자원이 할당되지 않고 stateless 하다는 특징이 있다. 유지되어야 하는 정보는
파라미터, 쿠키 등을 통해 쓸 수 있고, 중요한 정보는 파일 시스템, DB를 쓸 수 있다. 스프링은 기본적으로 상태가 유지되지 않는 빈이나 오브젝트를 권장한다.</p>
<p>서드 파티 프레임워크나 라이브러리도 사용가능한데, 스프링이 공식적으로 지원하는 지 확인하자! 스프링이 지원한다는 의미는
  <li>1. DI 패턴으로 사용할 수 있다는 뜻이다.</li>
<li>2. 스프링의 서비스 추상화가 적용되어있다.(비슷한 기술이면 일관된 접근을 가능하게 함)</li>
<li>3. 스프링이 지지하는 프로그래밍 모델이 적용 (데이터 엑세스에서 일관된 예외 적용이 예시)</li>
<li>4. 템플릿 콜백이 지원된다.</li>
</p>

<img data-action="zoom" src='{{ "/img/posts/spring/spring09_2.png" | relative_url }}' alt='absolute'>

<h2>DI와 인터페이스 프로그래밍</h2>
<p>DI에 인터페이스를 이용하는 이유 첫번 째는 다형성을 얻기 위해서다. 또한 다른 이유가 있다면 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확하게 하기 때문이다. 의존하는 오브젝트가 여러 인터페이스를 구현할 수 있다. 하지만 클라이언트는 내가 쓸 인터페이스만 알면 된다. 직접 의존하게 된다면 다른 인터페이스가 변화하면 그에 따라 내 클라이언트 로직도 바껴야 될 수 있는 문제가 있을 수 있다. 목적과 관심이 다른 클라이언트가 있다면 인터페이스로 이를 적절하게 분리하자(ISP)</p>
