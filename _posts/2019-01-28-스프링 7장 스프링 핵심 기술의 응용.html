---
layout: post
title:  "스프링 스터디 7장 스프링 핵심 기술의 응용"
date:   2019-03-10 20:00:00 -0400
subtitle: ""
categories : 스프링
background: '/img/posts/03.jpg'
---

<h2>인터페이스 상속을 통한 안전한 기능 확장</h2>
<p>DI의 가치를 누리기 위해서는 (객체지향 설계를 잘하기 위해서는) DI를 의식하면서 설계하자. 최소한 두 개 이상의, 의존관계를 가지고 협력하는 오브젝트가 필요하고, 적절한 책임에 따라 분리해야한다. DI는 런타임 시에 의존 오브젝트를 다이내믹하게 연결하고 유연한 확장을 하는 게 목적이다. 확장은 항상 미래에 일어난다. <b>'지금 당장 기능이 동작하는 데 아무런 문제가 없다고 생학하면 오늘을 위한 설계밖에 나오지 않는다' </b></p>

<h2>DI와 인터페이스 프로그래밍</h2>
<p>DI에 인터페이스를 이용하는 이유 첫번 째는 다형성을 얻기 위해서다. 또한 다른 이유가 있다면 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확하게 하기 때문이다. 의존하는 오브젝트가 여러 인터페이스를 구현할 수 있다. 하지만 클라이언트는 내가 쓸 인터페이스만 알면 된다. 직접 의존하게 된다면 다른 인터페이스가 변화하면 그에 따라 내 클라이언트 로직도 바껴야 될 수 있는 문제가 있을 수 있다. 목적과 관심이 다른 클라이언트가 있다면 인터페이스로 이를 적절하게 분리하자(ISP)</p>

<h2>인터페이스 상속</h2>
<img data-action="zoom" src='{{ "/img/posts/spring/spring07_1.JPG" | relative_url }}' alt='absolute'>
<p>DI를 사용하고 있는 전형적인 구조이다. SqlRegistry에서는 검색 및 등록하는 메소드만 있고, 클라이언트도 해당 기능만 사용한다. 하지만 업데이트를 하는 기능이 필요하다고 할 경우 새로운 클라이언트 및 인터페이스가 필요하다. SqlRegistry자체를 수정하는 건 바람직하지 않다. </p>
<img data-action="zoom" src='{{ "/img/posts/spring/spring07_2.JPG" | relative_url }}' alt='absolute'>
<img data-action="zoom" src='{{ "/img/posts/Udacity/spring07.JPG" | relative_url }}' alt='absolute'>
<img data-action="zoom" src='{{ "/img/posts/Udacity/spring07.jpg" | relative_url }}' alt='absolute'>
<img data-action="zoom" src='{{ "/img/posts/Udacity/visible.JPG" | relative_url }}' alt='absolute'>
<img data-action="zoom" src='{{ "/img/posts/Udacity/padding.JPG" | relative_url }}' alt='absolute'>
<p>새롭게 만들어진 확장 구조이다. SqlRegistry를 상속받아 추가 기능을 더 만들 수 있도록 한다. 기존에 BaseSqlService는 변화되는 것 없고, 새로 생긴 SqlAdminService 또한 기존의 기능까지 사용가능해 진 확장구조이다. </p>

<h2>DI를 이용해 다양한 구현 방법 적용하기</h2>
<p>Udpate 기능을 사용할 때는 동시성 문제를 항상 생각해야 한다. 기본으로 썼던 HashMapRegistry가 JDK HashMap을 사용하는데, 멀티스레드에서 안전하지 않고 Collections.synchronizedMap() 을 써도 되나 성능에 문제가 있다. ConcurrentHashMap을 사용하기를 권장한다. 전체 데이터에 락을 걸지 않고 조회 때는 아예 락을 사용하지 않기에 안전과 성능을 어느정도 보장한다</p>
<p>테스트 코드를 짜서 실제 동작하는 지 검증하자. OxmSqlService가 sqlRegistry 프로퍼티를 지정하지 않으면 HashMapSqlRegistry를 기본으로 사용하기 때문에, property 설정을 변경하여 sqlRegistry를 등록하고 이 빈이 ConcurrentHashMapSqlRegistry를 사용하도록 등록하자.</p>

<h2>내장형 데이터베이스를 이용한 SQL 레지스트리 만들기</h2>
<p>인덱스를 이용한 최적화된 검색 및 동시에 많은 요청도 처리하고 안정적인 변경작업이 가능한 기술은 데이터베이스다. 그렇기에 SQL 레지스트리를 DB를 사용하여 만들어 보겠다. DB를 구축하는 것은 거대한 작업이 될 수 있으니, 내장형 DB를 사용한다. 내장형 DB는 앱과 함께 시작되고 종료된다. 또한 데이터가 메모리에 저장되기 때문에 IO로 발생하는 부하가 적다. </p>
<p>자바에서 많이 쓰는 내장형 DB는 Derby, HSQL, H2이다. 모두 JDBC 드라이버를 제공하기에 기존 프로그래밍 모델과 동일하게 사용이 가능하다. 그러나 그대로 사용하면 안되고, 최초에 DB가동하고 초기화 SQL 스크립트 실행하는 등 초기화 작업이 별도로 필요하다. 그 후에는 JDBC를 이용해 사용하는 방식으로 동일하게 할 수 있다. 내장형 DB는 앱 안에서 직접 DB를 종료할 수 있어야한다. 스프링은 DataSource를 상속해서 shutdown()을 구현한 EmbeddedDatabase 인터페이스를 제공한다.</p>
<p>EmbeddedDatabaseBuilder를 통해서 초기화 코드를 사용하여 EmbeddedDatabase를 만든다. 최초에 한번만 초기화를 하고 생성하기 때문에 팩토리 빈을 만들어야 한다. 하지만 이미 내정형 DB 관련한 태그가 있기 때문에, 사용할 type이나 초기화 스크립트를 등록하기 편하다.</p>
<p>EmbeddedDatabaseBuilder를 통해서 초기화 코드를 사용하여 EmbeddedDatabase를 만든다. 최초에 한번만 초기화를 하고 생성하기 때문에 팩토리 빈을 만들어야 한다. 하지만 이미 내정형 DB 관련한 태그가 있기 때문에, 사용할 type이나 초기화 스크립트를 등록하기 편하다.</p>
<p>테스트 코드도 작성해야 하는데, 앞서서 만든 ConcurrentHashMapSqlRegistry와 동일하지만 사용하는 레지스트리만 달라지게 된다. 이럴경우 추상 테스트 클래스를 만들어서, 동일하게 쓰는 부분은 여기에서 그대로 두고, 변경되야 할 레지스트리 생성 부분만 추상 메소드로 두고 상속받아 구현하게 하면 된다. </p>
<p>여러 개의 SQL 을 수정할 때, 트랜잭션도 당연히 필요하다. HashMap은 구현하기 어렵지만 우리는 DB를 쓰기 때문에 쉽게 가능하다. 어차피 트랜잭션 매니저를 AOP에서 처럼 공유할 필요가 없기 때문에 Bean 등록하지 않고 TransactionTemplate를 내부에서 만들어서 사용하자.  </p>

<h2>스프링 3.1의 DI</h2>
<p>스프링이 DI를 사용하는 것은 변하지 않았지만, 자바가 많이 변화하고 스프링도 사용 방식이 변화하기 시작한다.</p>
<li>어노테이션의 메타정보 활용</li>
<p>메타정보를 이용한 프로그래밍 방식이 많이 활용된다. 리플랙션이 많이 활용되고 특히 어노테이션이 가장 그 절정이다. 어노테이션은 상속이나 참조, 오버라이딩 등이 가능하지 않다. 메타정보 조회 및 설정된 값을 찾아 참고하는 것이다. 이게 활용이 늘어난 이유는 핵심 로직을 담은 자바 코드, 이를 지원하는 IoC 방식의 프레임워크, 프레임워크가 참조하는 메타정보라는 세 가지 구성방식에 잘 어울리기 때문이다. XML을 통해서 메타정보를 등록했는데 이를 대체하는 방식으로 사용 가능하다.</p>
<p>단순하게 어노테이션을 붙이는 것 만으로 패키지, 클래스 이름, 접근 재한자, 상속 클래스 등을 알 수 있다. XML은 명시적으로 적어줘야 하는 게 더 많다. 리팩토링 시에도 장점이 있다. IDE를 통해서 이름을 변경하면 참조하는 곳의 이름도 알아서 바꿔주나, XML은 단순 텍스트라 그렇게 할 수 없다. 단점은 매번 새로 컴파일을 해줘야 한다는 점이다.</p>
<li>정책과 관례를 이용한 프로그래밍</li>
<p>이미 약속된 규칙으로 프로그래밍이 동작하게 되면 더 간결하게 사용된다. <bean>이라는 태그를 사용하는 것은 new를 통한 인스턴스 생성 코드가 동작한다는 규칙이다. 사실 정책을 잘 모른다면 의도한 대로 동작하지 않는 코드가 만들어 질 수 있다. XML이 편한사람이 있고, 어노테이션이 편한사람이 있을 것이다. 어쨰튼 스프링은 이제 어노테이션으로 거의 모든것을 할 수 있게 제공한다. </p>
<h2>자바 코드를 이용한 빈 설정</h2>
<p>XML 없애는 작업을 시작하자. 기존에 @ContextConfiguration(location="/test-application.xml")으로 DI 정보를 가져오고 있는데, 이를 다 변경할 것이다. 이것을 대체 할 수 있는 것은 @configuration 어노테이션이다. 한번에 다 옮기는 것은 어려우니, @ImportResource를 사용하면 자바클래스에서 XML 설정정보도 가져올 수 있어, 병행 사용이 가능하다.</p>
<p>@bean 어노테이션을 붙여서 XML을 옮기도록 하자. 중요한 것은 해당 메소드의 리턴값이 구체클래스가 되는 것이 아니라 인터페이스로 하여 다른 곳에서 가져다 쓸때 변경없도록 하자. 그리고 property를 통해 구체클래스에 값을 넣어줘야 할 경우가 있으면 내부에서 new를 통해 객체를 만들어 setter로 값을 직접 넣어주자. 또 자바클래스에서 기존 XML에 있는 빈을 참조하고 싶을 수 있다. 이때는 @Autowired를 써서 가져올 수 있다.</p>
<p>전용태그의 변환이 문제이다. tx의 경우 내부적으로 네 가지 클래스를 기본 빈으로 등록한다. 사실 이거를 다 파악하기는 어려워서 스프링 3.0에서는 XML을 계속 썼다. 하지만 3.1에서는 전용태그에 대응되는 어노테이션을 제공한다. @EnableTransactionManagement를 붙이면 해결된다. 일반적으로 전용태그는 @Enable로 시작된다.</p>

