---
layout: post
title:  "스프링 스터디 6장 AOP(2)"
date:   2019-01-31 02:00:00 -0400
subtitle: "Spring 3대 기반기술중 하나인 AOP"
categories : 스프링
background: '/img/posts/01.jpg'
---

<h2>스프링의 프록시 팩토리 빈</h2>
<p>스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공한다. ProxyFactoryBean이 순수하게 프록시를 생성하는 작업만 담당하게 된다. 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현하여 만든다. 타깃 오브젝트에 대한 정보도 함께 제공받기 때문에, 오브젝트 타깃이 다른 여러 프록시에서 함께 사용가능하고, 싱글톤 빈으로 등록 가능하다. </p>
<p>MethodInterceptor는 콜백 오브젝트로, proceed()메소드를 통해 타깃 오브젝트의 메소드를 내부적으로 실행해준다. ProxyFactoryBean에 addAdvice()라는 메소드로 여러개를 한번에 등록 할 수 있다. 이렇게 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 advice라고 부른다.</p>

<p>부가기능을 어떤 메소드에 적용할지를 선정하는 알고리즘을 담은 오브젝트가 포인트 컷이다. 포인트 컷과 어드바이스를 묶어서 등록하게 되는 데 이를 어드바이저라 부른다. 이렇게 하는 이유는 어떤 어드바이저에 어떤 포인트 컷을 적용할 지 사용자가 선택할 수 있게 하기 위해서 이다.</p>
<h2>스프링의 AOP</h2>
<p>부가기능이 매번 새로 만들어 지는 것은 어드바이스로 해결했으나, 매번 ProxyFactoryBean 설정을 중복해서 추가하는 것은 남아있다. 스프링은 OCP를 통해서 확장할 수 있는 포인트를 제공하는데, 빈 후처리기에 주목해보자. 이는 스프링 빈 오브젝트로 만들어 진 후에, 다시 가공할 수 있게 해주는 역할이다. DefaultAdvisorAutoProxyCreator를 사용할 것이다. 이를 사용하는 것은 빈 후처리기를 빈으로 등록하면 자동으로 빈 오브젝트가 생성될 때마다 후처리기에 보내서 후처리 작업을 요청하게 되는 방식이다. 포인트 컷으로 어떤 오브젝트를 등록할 지 확인 후, 프록시로 적용하게 된다</p>

<p>포인트 컷은 메소드를 선정하는 것이라고 했는데, 사실 클래스 매칭을 해주는 역할도 가능하다. 빈 설정을 할 때, 클래스 내의 스태틱 멤버 클래스(?)는 $으로 지정한다. 또한 parent 애트리뷰트를 통해서 다른 빈 설정의 내용을 상속도 가능하다.</p>
<p>포인트 컷 표현식으로 좀더 정교하게 패턴의 매칭이 가능하다. AspectJExpressionPointcut 클래스를 사용해야한다. execution([접근제한자 패턴] 리턴 값의 타입 패턴 [패키지와 클래스에 대한 타입패턴 .] 메소드 이름 패턴 (파라미터의 타입패턴 | ".." , ...) [trhows 예외 이름 패턴]) 으로 사용한다. 이는 메소드 오브젝트를 출력했을 때 나오는 것과 동일하기 때문에 참고하자. 다만 생략하는 부분은 모든 경우를 허용하겠다는 의미로 사용된다. 포인트 컷의 클래스 이름에 적용되는 것은 타입 패턴 이기 때문에, 이름이 매칭 되는 것이 아니라 해당 타입이면 매칭될 수 있다.</p>
<p>부가기능 모듈화 작업은 기존의 객체지향 설계 패러다임과는 구분된다고 생각하여 aspect라 부르기 시작했다. 이것은 애플리케이션의 핵심기능을 담고 있지는 않지만 애플리케이션을 구성하는 중요한 한 가지 요소이다. AOP는 OOP를 돕는 부가적인 기술이라 생각하자. </p>
<p>스프링은 프록시 방식의 AOP를 사용한다. 빈 사이에 프록시가 적용되어 타깃의 메소드 호출과정에서 부가기능을 제공해주도록 만들어져있는 형태이다. AspectJ는 타깃 오브젝트를 뜯어고쳐서 부가기능을 넣어주는 직접적인 방법을 사용한다. 직접 바이트코드를 조작하는 것인데, 이게 더 강력하고 유연하다. 메소드 뿐 아니라, 오브젝트 생성 및 필드 값 조작 등 다양한 기능이 가능하다.</p>
<p>스프링의 프록시 방식 AOP를 적용하려면 최소 네 가지 빈을 적용해야 한다</p>
<li>자동 프록시 생성기</li>
<li>어드바이스</li>
<li>포인트컷</li>
<li>어드바이저</li>
<p>이를 편리하게 사용하기 위해서 AOP 네임스페이스를 이용하자 </p>

<h2>트랜잭션 속성</h2>
<p>트랜잭션이라고 모두 같은 방식은 아니다. 더 이상 쪼갤 수 없는 최소 단위의 작업이라는 개념은 유효하다. commit으로 성공하거나 rollback으로 모두 취소되는 것 외에도 동작을 제어하는 것이 있다.</p>
<p>트랜잭션 전파란 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때나 없을 때 어떻게 동작할 것인가를 결정하는 방식이다. 두 개의 트랜잭션이 얽혀있을 때, 하나가 취소되면 이미 진행중인 트랜잭션에 어떻게 영향을 미칠 것 인가를 생각하면 된다. </p>
<p>PROPAGATION_REQUIRE는 가장 많이 사용되는 속성이다. 진행중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 것이 있으면 이에 참여한다.</p>
<p>PROPAGATION_REQUIRES_NEW는 항상 새로운 트랜잭션의 시작이다. 독립적인 트랜잭션이 보장되어야 할 경우 사용한다</p>
<p>PROPAGATION_NOT_SUPPORTED는 트랜잭션 없이 동작하게 만들 수 있다. 진행 중인 트랜잭션도 무시하는 속성이다. (PROPAGATION_REQUIRES_NEW는와 차이?) </p>
<p>모든 DB 트랜잭션은 격리수준을 갖고 있어야 한다. 가능한 많은 트랜잭션을 동시에 하면서도 문제가 발생하지 않게 하는 제어가 필요하다. </p>
<p>트랜잭션을 수행하는 제한시간도 설정이 가능하다. 읽기전용으로 설정하면 트랜잭션 내에서 데이터를 조작하지 못하게 할 수 있다. 이런 트랜잭션의 다양한 정의들을 설정하고 싶다면 TransactionInterceptor를 사용해야한다. 트랜잭션 정의를 할 때, 어떤 기능을 수행할지와, 예외를 던지는 것을 통해 언제 롤백을 할지를 결정하게 할 수 있다. 이러한 값들을 Properties라는 맵 타입 오브젝트롤 전달받아 명시한다. PROPAGATION_NAME, ISOLATION_NAME, readOnly, timeout_NNNN, -Exception1(체크), +Exception2(런타임) 이 형식ㅇ긴데, 트랜잭션 전파 항목만 필수이다. 생략시 DefaultTransactionDefinition에 설정된 속성이 부여된다. </p>
<p>이러한 속성도 AOP 전용 태그 처럼, tx 스키마 전용 태그를 이용해 편하게 정의가 가능하다. </p>
<p>포인트컷과 트랜잭션 속성의 적용에 대한 좋은 전략이 있다. 1. 트랜잭션 포인트컷 표현식은 타입패턴이나 빈 이름을 이용하자. 통째로 만드는 것이 좋다  2.공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다. 너무 많은 트랜잭션 속성은 관리만 힘들어 지니, 기준을 만들어 놓고 적절한 명명 규칙으로 구분하자. 3. 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다. 프록시에서 부가 기능을 타는데, 프록시없이 자체 동작이기 때문이다.</p>
<p>트랜잭션 경계설정의 부가기능은 비즈니스 로직을 담고이ㅆ는 서비스 계층 오브젝트의 메소드에 부여하자. </p>